{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RxDogTag RxDogTag is a utility to tag originating subscribe points in RxJava 2 observers, with the goal of surfacing their subscribe locations for error reporting/investigation later in the event of an unhandled error. This is only for RxJava observers that do not implement onError() . Download implementation( com.uber.rxdogtag:rxdogtag:x.y.z ) Setup Install early in your application lifecycle via RxDogTag.install() . This will install the necessary hooks in RxJavaPlugins . Note that these will replace any existing plugins at the hooks it uses. See the JavaDoc for full details of which plugins it uses. Example Consider the following classic RxJava error: Observable . range ( 0 , 10 ) . subscribeOn ( Schedulers . io ()) . map ( i - null ) . subscribe (); This is a fairly common case in RxJava concurrency. Without tagging, this yields the following trace: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | The mapper function returned a null value. at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.BasicFuseableObserver.onError(BasicFuseableObserver.java:100) at io.reactivex.internal.observers.BasicFuseableObserver.fail(BasicFuseableObserver.java:110) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:59) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NullPointerException: The mapper function returned a null value. at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) ... 14 more This is basically impossible to investigate if you re looking at a crash report from the wild. Now the same error with RxDogTag enabled: io.reactivex.exceptions.OnErrorNotImplementedException: The mapper function returned a null value. Caused by: java.lang.NullPointerException: The mapper function returned a null value. at com.uber.anotherpackage.ReadMeExample.complex(ReadMeExample.java:55) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Now we have the example subscribe line at ReadMeExample.java:55 . It may not be a silver bullet to root-causing why the exception occurred, but at least you know where it s emanating from. The subscribe line reported should also retrace and group well for crash reporting. As we use our own in-house reporter though, we re very open to feedback on how this can be improved for other solutions. More examples and details can be found in the wiki Configuration RxDogTag has an alternative RxDogTag.builder() API to facilitate added configuration, such as annotation control, stacktrace element location, and more. Custom handlers In the event of custom observers that possibly decorate other observer types, this information can be passed to RxDogTag via the ObserverHandler interface. This interface can be used to unwrap these custom observers to reveal their delegates and their potential behavior. Install these via the RxDogTag.Builder#addObserverHandlers(...) overloads that accept handlers. Ignored packages RxDogTag needs to ignore certain packages (such as its own or RxJava s) when inspecting stack traces to deduce the subscribe point. You can add other custom ones via RxDogTag.Builder#addIgnoredPackages(...) . AutoDispose support AutoDispose is a library for automatically disposing streams, and works via its own decorating observers under the hood. AutoDispose can work with RxDogTag via its delegateObserver() APIs on the AutoDisposingObserver interfaces. Support for this is available via separate rxdogtag-autodispose artifact and its AutoDisposeObserverHandler singleton instance. RxDogTag . builder () . configureWith ( AutoDisposeConfigurer :: configure ) . install (); implementation( com.uber.rxdogtag:rxdogtag-autodispose:x.y.z ) Development Javadocs for the most recent release can be found here: https://uber.github.io/RxDogTag/0.x/ Snapshots of the development version are available in Sonatype s snapshots repository . License Copyright (C) 2019 Uber Technologies Licensed under the Apache License, Version 2.0 (the License ); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#rxdogtag","text":"RxDogTag is a utility to tag originating subscribe points in RxJava 2 observers, with the goal of surfacing their subscribe locations for error reporting/investigation later in the event of an unhandled error. This is only for RxJava observers that do not implement onError() .","title":"RxDogTag"},{"location":"#download","text":"implementation( com.uber.rxdogtag:rxdogtag:x.y.z )","title":"Download"},{"location":"#setup","text":"Install early in your application lifecycle via RxDogTag.install() . This will install the necessary hooks in RxJavaPlugins . Note that these will replace any existing plugins at the hooks it uses. See the JavaDoc for full details of which plugins it uses.","title":"Setup"},{"location":"#example","text":"Consider the following classic RxJava error: Observable . range ( 0 , 10 ) . subscribeOn ( Schedulers . io ()) . map ( i - null ) . subscribe (); This is a fairly common case in RxJava concurrency. Without tagging, this yields the following trace: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | The mapper function returned a null value. at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.BasicFuseableObserver.onError(BasicFuseableObserver.java:100) at io.reactivex.internal.observers.BasicFuseableObserver.fail(BasicFuseableObserver.java:110) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:59) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NullPointerException: The mapper function returned a null value. at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) ... 14 more This is basically impossible to investigate if you re looking at a crash report from the wild. Now the same error with RxDogTag enabled: io.reactivex.exceptions.OnErrorNotImplementedException: The mapper function returned a null value. Caused by: java.lang.NullPointerException: The mapper function returned a null value. at com.uber.anotherpackage.ReadMeExample.complex(ReadMeExample.java:55) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Now we have the example subscribe line at ReadMeExample.java:55 . It may not be a silver bullet to root-causing why the exception occurred, but at least you know where it s emanating from. The subscribe line reported should also retrace and group well for crash reporting. As we use our own in-house reporter though, we re very open to feedback on how this can be improved for other solutions. More examples and details can be found in the wiki","title":"Example"},{"location":"#configuration","text":"RxDogTag has an alternative RxDogTag.builder() API to facilitate added configuration, such as annotation control, stacktrace element location, and more.","title":"Configuration"},{"location":"#custom-handlers","text":"In the event of custom observers that possibly decorate other observer types, this information can be passed to RxDogTag via the ObserverHandler interface. This interface can be used to unwrap these custom observers to reveal their delegates and their potential behavior. Install these via the RxDogTag.Builder#addObserverHandlers(...) overloads that accept handlers.","title":"Custom handlers"},{"location":"#ignored-packages","text":"RxDogTag needs to ignore certain packages (such as its own or RxJava s) when inspecting stack traces to deduce the subscribe point. You can add other custom ones via RxDogTag.Builder#addIgnoredPackages(...) .","title":"Ignored packages"},{"location":"#autodispose-support","text":"AutoDispose is a library for automatically disposing streams, and works via its own decorating observers under the hood. AutoDispose can work with RxDogTag via its delegateObserver() APIs on the AutoDisposingObserver interfaces. Support for this is available via separate rxdogtag-autodispose artifact and its AutoDisposeObserverHandler singleton instance. RxDogTag . builder () . configureWith ( AutoDisposeConfigurer :: configure ) . install (); implementation( com.uber.rxdogtag:rxdogtag-autodispose:x.y.z )","title":"AutoDispose support"},{"location":"#development","text":"Javadocs for the most recent release can be found here: https://uber.github.io/RxDogTag/0.x/ Snapshots of the development version are available in Sonatype s snapshots repository .","title":"Development"},{"location":"#license","text":"Copyright (C) 2019 Uber Technologies Licensed under the Apache License, Version 2.0 (the License ); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"benchmark/","text":"Benchmarks Running the benchmark You can run the benchmark by executing ./gradlew :android-benchmark:benchmark:connectedCheck . Note that the benchmark should be run on an actual device You can then take the output from the benchmark and run it through DataParser.kt to get a structured breakdown as seen below. It s important to look at the units than at the percentages. In general, RxDogTag does add some overhead to your RxJava subscriptions but that overhead is irrelevant in the larger execution context of the code around it (less than a millisecond in most cases). Results Running the benchmark on a Pixel 3 yields the following results: Event throughput (grouped by number of events) Measures the amount of time it takes for given number of elements to pass through the stream. 1 item (Observable) Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.observable1_false 212ns 0.000ms RxDogTagAndroidPerf.observable1_true 13,267ns 0.013ms 6158.02% 1 item (Flowable) Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.flowable1_false 223ns 0.000ms RxDogTagAndroidPerf.flowable1_true 13,129ns 0.013ms 5787.44% 1000 items (Observable) Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.observable1000_false 17,596ns 0.018ms RxDogTagAndroidPerf.observable1000_true 156,953ns 0.157ms 791.98% 1000 items (Flowable) Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.flowable1000_false 17,854ns 0.018ms RxDogTagAndroidPerf.flowable1000_true 143,646ns 0.144ms 704.56% 1_000_000 items (Observable) Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.observable1000000_false 17,078,596ns 17.079ms RxDogTagAndroidPerf.observable1000000_true 161,099,912ns 161.100ms 843.29% 1_000_000 items (Flowable) Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.flowable1000000_false 17,790,262ns 17.790ms RxDogTagAndroidPerf.flowable1000000_true 152,887,724ns 152.888ms 759.39% Subscribe Cost (grouped by complexity) This measures the cost to subscription incurred by RxDogTag. Simple (Observable) Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.observable_false_subscribe_simple 112ns 0.000ms RxDogTagAndroidPerf.observable_true_subscribe_simple 13,017ns 0.013ms 11522.32% Simple (Flowable) Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.flowable_false_subscribe_simple 147ns 0.000ms RxDogTagAndroidPerf.flowable_true_subscribe_simple 12,725ns 0.013ms 8556.46% Complex (Observable) Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.observable_false_subscribe_complex 5,322ns 0.005ms RxDogTagAndroidPerf.observable_true_subscribe_complex 25,046ns 0.025ms 370.61% Complex (Flowable) Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.flowable_false_subscribe_complex 8,376ns 0.008ms RxDogTagAndroidPerf.flowable_true_subscribe_complex 49,184ns 0.049ms 487.20% End-to-end amortized cost This measures the end-to-end amortized cost. Observable Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.observable_false_e2e 99,010ns 0.099ms RxDogTagAndroidPerf.observable_true_e2e 145,833ns 0.146ms 47.29% Flowable Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.flowable_false_e2e 126,371ns 0.126ms RxDogTagAndroidPerf.flowable_true_e2e 153,107ns 0.153ms 21.16%","title":"Benchmark"},{"location":"benchmark/#benchmarks","text":"","title":"Benchmarks"},{"location":"benchmark/#running-the-benchmark","text":"You can run the benchmark by executing ./gradlew :android-benchmark:benchmark:connectedCheck . Note that the benchmark should be run on an actual device You can then take the output from the benchmark and run it through DataParser.kt to get a structured breakdown as seen below. It s important to look at the units than at the percentages. In general, RxDogTag does add some overhead to your RxJava subscriptions but that overhead is irrelevant in the larger execution context of the code around it (less than a millisecond in most cases).","title":"Running the benchmark"},{"location":"benchmark/#results","text":"Running the benchmark on a Pixel 3 yields the following results:","title":"Results"},{"location":"benchmark/#event-throughput-grouped-by-number-of-events","text":"Measures the amount of time it takes for given number of elements to pass through the stream.","title":"Event throughput (grouped by number of events)"},{"location":"benchmark/#1-item-observable","text":"Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.observable1_false 212ns 0.000ms RxDogTagAndroidPerf.observable1_true 13,267ns 0.013ms 6158.02%","title":"1 item (Observable)"},{"location":"benchmark/#1-item-flowable","text":"Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.flowable1_false 223ns 0.000ms RxDogTagAndroidPerf.flowable1_true 13,129ns 0.013ms 5787.44%","title":"1 item (Flowable)"},{"location":"benchmark/#1000-items-observable","text":"Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.observable1000_false 17,596ns 0.018ms RxDogTagAndroidPerf.observable1000_true 156,953ns 0.157ms 791.98%","title":"1000 items (Observable)"},{"location":"benchmark/#1000-items-flowable","text":"Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.flowable1000_false 17,854ns 0.018ms RxDogTagAndroidPerf.flowable1000_true 143,646ns 0.144ms 704.56%","title":"1000 items (Flowable)"},{"location":"benchmark/#1_000_000-items-observable","text":"Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.observable1000000_false 17,078,596ns 17.079ms RxDogTagAndroidPerf.observable1000000_true 161,099,912ns 161.100ms 843.29%","title":"1_000_000 items (Observable)"},{"location":"benchmark/#1_000_000-items-flowable","text":"Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.flowable1000000_false 17,790,262ns 17.790ms RxDogTagAndroidPerf.flowable1000000_true 152,887,724ns 152.888ms 759.39%","title":"1_000_000 items (Flowable)"},{"location":"benchmark/#subscribe-cost-grouped-by-complexity","text":"This measures the cost to subscription incurred by RxDogTag.","title":"Subscribe Cost (grouped by complexity)"},{"location":"benchmark/#simple-observable","text":"Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.observable_false_subscribe_simple 112ns 0.000ms RxDogTagAndroidPerf.observable_true_subscribe_simple 13,017ns 0.013ms 11522.32%","title":"Simple (Observable)"},{"location":"benchmark/#simple-flowable","text":"Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.flowable_false_subscribe_simple 147ns 0.000ms RxDogTagAndroidPerf.flowable_true_subscribe_simple 12,725ns 0.013ms 8556.46%","title":"Simple (Flowable)"},{"location":"benchmark/#complex-observable","text":"Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.observable_false_subscribe_complex 5,322ns 0.005ms RxDogTagAndroidPerf.observable_true_subscribe_complex 25,046ns 0.025ms 370.61%","title":"Complex (Observable)"},{"location":"benchmark/#complex-flowable","text":"Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.flowable_false_subscribe_complex 8,376ns 0.008ms RxDogTagAndroidPerf.flowable_true_subscribe_complex 49,184ns 0.049ms 487.20%","title":"Complex (Flowable)"},{"location":"benchmark/#end-to-end-amortized-cost","text":"This measures the end-to-end amortized cost.","title":"End-to-end amortized cost"},{"location":"benchmark/#observable","text":"Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.observable_false_e2e 99,010ns 0.099ms RxDogTagAndroidPerf.observable_true_e2e 145,833ns 0.146ms 47.29%","title":"Observable"},{"location":"benchmark/#flowable","text":"Benchmark Time (ns) Time (ms) Percent Increase RxDogTagAndroidPerf.flowable_false_e2e 126,371ns 0.126ms RxDogTagAndroidPerf.flowable_true_e2e 153,107ns 0.153ms 21.16%","title":"Flowable"},{"location":"changelog/","text":"Changelog Version 0.2.0 2019-05-14 New: Builder-based API for configuration RxDogTag now uses a builder API for configuration. Currently this includes the existing ObserverHandler and package whitelisting, as well as a new configuration to optionally disable stacktrace annotations. RxDogTag . builder () . disableAnnotations () . addObserverHandlers (...) . addIgnoredPackages (...) . configureWith (...) // For other custom AutoDispose.Configurers . install (); Note: No-config RxDogTag.install() still exists, but is now just a proxy to RxDogTag.builder().install() Breaking changes: * ObserverHandler no longer handles package whitelisting, as this is now moved to the builder API. * The AutoDispose artifact now uses the builder API s configureWith support, and AutoDisposeObserverHandler is now just a package-private implementation detail. RxDogTag . builder () . configureWith ( AutoDisposeConfigurer :: configure ) . install (); New: Inferred subscribe point is now the first element in the stacktrace. After discussions with others in the community, the inferred subscribe point is now the first element in the stacktrace for better grouping with crash reporters (which may have otherwise accidentally grouped the stacktrace header annotations as the same crash). This plus some arrow characters means the stacktraces look like this: io.reactivex.exceptions.OnErrorNotImplementedException: The mapper function returned a null value. Caused by: java.lang.NullPointerException: The mapper function returned a null value. at com.uber.anotherpackage.ReadMeExample.complex(ReadMeExample.java:55) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) // ... and so on Version 0.1.0 2019-04-09 Initial release!","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#version-020","text":"2019-05-14 New: Builder-based API for configuration RxDogTag now uses a builder API for configuration. Currently this includes the existing ObserverHandler and package whitelisting, as well as a new configuration to optionally disable stacktrace annotations. RxDogTag . builder () . disableAnnotations () . addObserverHandlers (...) . addIgnoredPackages (...) . configureWith (...) // For other custom AutoDispose.Configurers . install (); Note: No-config RxDogTag.install() still exists, but is now just a proxy to RxDogTag.builder().install() Breaking changes: * ObserverHandler no longer handles package whitelisting, as this is now moved to the builder API. * The AutoDispose artifact now uses the builder API s configureWith support, and AutoDisposeObserverHandler is now just a package-private implementation detail. RxDogTag . builder () . configureWith ( AutoDisposeConfigurer :: configure ) . install (); New: Inferred subscribe point is now the first element in the stacktrace. After discussions with others in the community, the inferred subscribe point is now the first element in the stacktrace for better grouping with crash reporters (which may have otherwise accidentally grouped the stacktrace header annotations as the same crash). This plus some arrow characters means the stacktraces look like this: io.reactivex.exceptions.OnErrorNotImplementedException: The mapper function returned a null value. Caused by: java.lang.NullPointerException: The mapper function returned a null value. at com.uber.anotherpackage.ReadMeExample.complex(ReadMeExample.java:55) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) // ... and so on","title":"Version 0.2.0"},{"location":"changelog/#version-010","text":"2019-04-09 Initial release!","title":"Version 0.1.0"},{"location":"code-of-conduct/","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at . The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project s leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/","title":"Code of Conduct"},{"location":"code-of-conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at . The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project s leadership.","title":"Enforcement"},{"location":"code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/","title":"Attribution"},{"location":"contributing/","text":"Contributing to RxDogTag The Uber team welcomes contributions of all kinds, from simple bug reports through documentation, test cases, bugfixes, and features. Workflow We love GitHub issues! For small feature requests, an issue first proposing it for discussion or demo implementation in a PR suffice. For big features, please open an issue so that we can agree on the direction, and hopefully avoid investing a lot of time on a feature that might need reworking. Small pull requests for things like typos, bugfixes, etc are always welcome. Code style This project uses ktlint and GJF , provided via the spotless gradle plugin. If you find that one of your pull reviews does not pass the CI server check due to a code style conflict, you can easily fix it by running: ./gradlew spotlessApply. Generally speaking - we use vanilla ktlint + 2space indents, and vanilla GJF. You can integrate both of these in IntelliJ code style via either GJF s official plugin or applying code style from Jetbrains official style. No star imports please! DOs and DON Ts DO follow our coding style DO include tests when adding new features. When fixing bugs, start with adding a test that highlights how the current behavior is broken. DO keep the discussions focused. When a new or related topic comes up it s often better to create new issue than to side track the discussion. DO run all Gradle verification tasks ( ./gradlew check ) before submitting a pull request DON T submit PRs that alter licensing related files or headers. If you believe there s a problem with them, file an issue and we ll be happy to discuss it.","title":"Contributing"},{"location":"contributing/#contributing-to-rxdogtag","text":"The Uber team welcomes contributions of all kinds, from simple bug reports through documentation, test cases, bugfixes, and features.","title":"Contributing to RxDogTag"},{"location":"contributing/#workflow","text":"We love GitHub issues! For small feature requests, an issue first proposing it for discussion or demo implementation in a PR suffice. For big features, please open an issue so that we can agree on the direction, and hopefully avoid investing a lot of time on a feature that might need reworking. Small pull requests for things like typos, bugfixes, etc are always welcome.","title":"Workflow"},{"location":"contributing/#code-style","text":"This project uses ktlint and GJF , provided via the spotless gradle plugin. If you find that one of your pull reviews does not pass the CI server check due to a code style conflict, you can easily fix it by running: ./gradlew spotlessApply. Generally speaking - we use vanilla ktlint + 2space indents, and vanilla GJF. You can integrate both of these in IntelliJ code style via either GJF s official plugin or applying code style from Jetbrains official style. No star imports please!","title":"Code style"},{"location":"contributing/#dos-and-donts","text":"DO follow our coding style DO include tests when adding new features. When fixing bugs, start with adding a test that highlights how the current behavior is broken. DO keep the discussions focused. When a new or related topic comes up it s often better to create new issue than to side track the discussion. DO run all Gradle verification tasks ( ./gradlew check ) before submitting a pull request DON T submit PRs that alter licensing related files or headers. If you believe there s a problem with them, file an issue and we ll be happy to discuss it.","title":"DOs and DON'Ts"},{"location":"examples/","text":"Examples Simple Consider the following trivial case of emitting an error with no error handling. Observable . error ( new RuntimeException ( Unhandled error! )) . subscribe (); This results in a stacktrace like this: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | Unhandled error! at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63) at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:38) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.Observable.subscribe(Observable.java:12076) at io.reactivex.Observable.subscribe(Observable.java:11954) at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:26) collapsed internal calls Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:25) ... 25 more Now let s look at the same example with tagging enabled: io.reactivex.exceptions.OnErrorNotImplementedException: Unhandled error! Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:26) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:25) ... 25 more In the simple case, there s not much added benefit since the execution was synchronous and single threaded, but you can see original trace has now been updated to indicate the exact line that subscribe() was called. In this case: ReadMeExample.java:26 . To reduce noise - RxDogTag will wrap the original cause in a synthetic OnErrorNotImplementedException . This uses the original cause s message and doesn t fill in the stacktrace as it s irrelevant to the trace. Threading Consider a more complex example with threading: Observable . just ( 1 ) . subscribeOn ( Schedulers . io ()) . map ( i - null ) . subscribe (); This is a fairly common case in RxJava concurrency. Without tagging, this yields the following trace: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | The mapper function returned a null value. at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.BasicFuseableObserver.onError(BasicFuseableObserver.java:100) at io.reactivex.internal.observers.BasicFuseableObserver.fail(BasicFuseableObserver.java:110) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:59) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NullPointerException: The mapper function returned a null value. at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) ... 14 more Yikes! This is basically impossible to investigate if you re looking at a crash report from the wild. Now the same trace with tagging enabled: io.reactivex.exceptions.OnErrorNotImplementedException: The mapper function returned a null value. Caused by: java.lang.NullPointerException: The mapper function returned a null value. at com.uber.anotherpackage.ReadMeExample.complex(ReadMeExample.java:55) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Now we have the example subscribe line at ReadMeExample.java:55 . It may not be a silver bullet to root-causing why the exception occurred, but at least you know where it s emanating from. Delegate callbacks Let s look at one more example. This is similar to the previous, but instead of the exception occurring upstream in the chain, the exception occurs in one of the observer callbacks; in this case - onNext . Observable . just ( 1 ) . subscribeOn ( Schedulers . io ()) . subscribe ( i - throwSomething ()); private void throwSomething () { throw new RuntimeException ( Unhandled error! ); } Without tagging, this yields the following trace: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | Unhandled error! at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:67) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.throwSomething(ReadMeExample.java:68) at com.uber.anotherpackage.ReadMeExample.lambda$complexDelegate$1(ReadMeExample.java:63) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:63) ... 14 more Similar to the first example, this isn t terrible to root-cause. onNext is throwing a traceable exception in this trivial case. With tagging enabled: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | Unhandled error! at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:67) at com.uber.rxdogtag.DogTagObserver.lambda$onNext$3(DogTagObserver.java:53) at com.uber.rxdogtag.RxDogTag.guardedDelegateCall(RxDogTag.java:262) at com.uber.rxdogtag.DogTagObserver.onNext(DogTagObserver.java:53) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.complexDelegate(ReadMeExample.java:63) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ Originating callback: onNext ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at com.uber.anotherpackage.ReadMeExample.throwSomething(ReadMeExample.java:68) at com.uber.anotherpackage.ReadMeExample.lambda$complexDelegate$1(ReadMeExample.java:63) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:63) ... 17 more Now we re given added context that this occurred in the onNext callback according to [[ Originating callback: onNext ]] at the subscribe() call at ReadMeExample.java:63 . This callback handling is supported for all the standard callbacks and will report the correct name for each ( onSuccess , onComplete , etc).","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#simple","text":"Consider the following trivial case of emitting an error with no error handling. Observable . error ( new RuntimeException ( Unhandled error! )) . subscribe (); This results in a stacktrace like this: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | Unhandled error! at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.disposables.EmptyDisposable.error(EmptyDisposable.java:63) at io.reactivex.internal.operators.observable.ObservableError.subscribeActual(ObservableError.java:38) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.Observable.subscribe(Observable.java:12076) at io.reactivex.Observable.subscribe(Observable.java:11954) at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:26) collapsed internal calls Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:25) ... 25 more Now let s look at the same example with tagging enabled: io.reactivex.exceptions.OnErrorNotImplementedException: Unhandled error! Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:26) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at com.uber.anotherpackage.ReadMeExample.simpleSubscribe(ReadMeExample.java:25) ... 25 more In the simple case, there s not much added benefit since the execution was synchronous and single threaded, but you can see original trace has now been updated to indicate the exact line that subscribe() was called. In this case: ReadMeExample.java:26 . To reduce noise - RxDogTag will wrap the original cause in a synthetic OnErrorNotImplementedException . This uses the original cause s message and doesn t fill in the stacktrace as it s irrelevant to the trace.","title":"Simple"},{"location":"examples/#threading","text":"Consider a more complex example with threading: Observable . just ( 1 ) . subscribeOn ( Schedulers . io ()) . map ( i - null ) . subscribe (); This is a fairly common case in RxJava concurrency. Without tagging, this yields the following trace: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | The mapper function returned a null value. at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.BasicFuseableObserver.onError(BasicFuseableObserver.java:100) at io.reactivex.internal.observers.BasicFuseableObserver.fail(BasicFuseableObserver.java:110) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:59) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NullPointerException: The mapper function returned a null value. at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) ... 14 more Yikes! This is basically impossible to investigate if you re looking at a crash report from the wild. Now the same trace with tagging enabled: io.reactivex.exceptions.OnErrorNotImplementedException: The mapper function returned a null value. Caused by: java.lang.NullPointerException: The mapper function returned a null value. at com.uber.anotherpackage.ReadMeExample.complex(ReadMeExample.java:55) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at io.reactivex.internal.functions.ObjectHelper.requireNonNull(ObjectHelper.java:39) at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:57) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Now we have the example subscribe line at ReadMeExample.java:55 . It may not be a silver bullet to root-causing why the exception occurred, but at least you know where it s emanating from.","title":"Threading"},{"location":"examples/#delegate-callbacks","text":"Let s look at one more example. This is similar to the previous, but instead of the exception occurring upstream in the chain, the exception occurs in one of the observer callbacks; in this case - onNext . Observable . just ( 1 ) . subscribeOn ( Schedulers . io ()) . subscribe ( i - throwSomething ()); private void throwSomething () { throw new RuntimeException ( Unhandled error! ); } Without tagging, this yields the following trace: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | Unhandled error! at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:67) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.throwSomething(ReadMeExample.java:68) at com.uber.anotherpackage.ReadMeExample.lambda$complexDelegate$1(ReadMeExample.java:63) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:63) ... 14 more Similar to the first example, this isn t terrible to root-cause. onNext is throwing a traceable exception in this trivial case. With tagging enabled: io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | Unhandled error! at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704) at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701) at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:77) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:67) at com.uber.rxdogtag.DogTagObserver.lambda$onNext$3(DogTagObserver.java:53) at com.uber.rxdogtag.RxDogTag.guardedDelegateCall(RxDogTag.java:262) at com.uber.rxdogtag.DogTagObserver.onNext(DogTagObserver.java:53) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onNext(ObservableSubscribeOn.java:58) at io.reactivex.internal.operators.observable.ObservableScalarXMap$ScalarDisposable.run(ObservableScalarXMap.java:248) at io.reactivex.internal.operators.observable.ObservableJust.subscribeActual(ObservableJust.java:35) at io.reactivex.Observable.subscribe(Observable.java:12090) at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578) at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.RuntimeException: Unhandled error! at com.uber.anotherpackage.ReadMeExample.complexDelegate(ReadMeExample.java:63) at [[ \u2191\u2191 Inferred subscribe point \u2191\u2191 ]].(:0) at [[ Originating callback: onNext ]].(:0) at [[ \u2193\u2193 Original trace \u2193\u2193 ]].(:0) at com.uber.anotherpackage.ReadMeExample.throwSomething(ReadMeExample.java:68) at com.uber.anotherpackage.ReadMeExample.lambda$complexDelegate$1(ReadMeExample.java:63) at io.reactivex.internal.observers.LambdaObserver.onNext(LambdaObserver.java:63) ... 17 more Now we re given added context that this occurred in the onNext callback according to [[ Originating callback: onNext ]] at the subscribe() call at ReadMeExample.java:63 . This callback handling is supported for all the standard callbacks and will report the correct name for each ( onSuccess , onComplete , etc).","title":"Delegate callbacks"},{"location":"shrinking/","text":"Proguard/R8 In order to correctly identify which line is the subscribe() line, RxDogTag requires keeping the names of any types in io.reactivex or com.uber.rxdogtag packages. This doesn t prevent shrinking unused types, and as these are open source projects we don t think keeping these public risks any sort of secret sauce. Keeping names has a negligible impact on APK size as well. If this is an issue for you though, then RxDogTag is probably not the right solution for your project. RxDogTag ships with custom rxdogtag.pro rules in the jar resources to handle this automatically.","title":"Proguard/R8"},{"location":"shrinking/#proguardr8","text":"In order to correctly identify which line is the subscribe() line, RxDogTag requires keeping the names of any types in io.reactivex or com.uber.rxdogtag packages. This doesn t prevent shrinking unused types, and as these are open source projects we don t think keeping these public risks any sort of secret sauce. Keeping names has a negligible impact on APK size as well. If this is an issue for you though, then RxDogTag is probably not the right solution for your project. RxDogTag ships with custom rxdogtag.pro rules in the jar resources to handle this automatically.","title":"Proguard/R8"},{"location":"under-the-hood/","text":"Under the hood More information on LambdaConsumerIntrospection can be found in its implementation PR: https://github.com/ReactiveX/RxJava/pull/5590 Decision tree: - Is the observer an instance of `LambdaConsumerIntrospection`? - Does `hasCustomOnError()` return `false`? - Decorate with a DogTag observer.","title":"Under The Hood"},{"location":"under-the-hood/#under-the-hood","text":"More information on LambdaConsumerIntrospection can be found in its implementation PR: https://github.com/ReactiveX/RxJava/pull/5590 Decision tree: - Is the observer an instance of `LambdaConsumerIntrospection`? - Does `hasCustomOnError()` return `false`? - Decorate with a DogTag observer.","title":"Under the hood"}]}